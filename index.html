<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI å¯¹è¯</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/line-numbers/prism-line-numbers.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism.min.css">
  <link rel="stylesheet" id="theme-link" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism.min.css">
  <link rel="stylesheet" href="index-ai.css">
</head>

<body>
  <div id="app" v-cloak>
    <div class="sidebar" :class="{ hidebar: !showSidebar }">
      <div class="side-setting">
        <div class="theme-toggle" @click="toggleTheme">{{ isDarkMode ? 'â˜€ï¸' : 'ğŸŒ™' }}</div>
        <div class="setting-icon" title="è®¾ç½®" @click="open('setting.html')">âš™ï¸</div>
      </div>
      <div class="sidebar-header">
        <select v-model="currProvider" @change="providerChange" placeholder="é€‰æ‹©æœåŠ¡å•†">
          <option v-for="provider in providers" :key="provider.name" :value="provider.name">{{ provider.name }}</option>
        </select>
        <select v-model="currModel" @change="modelChange" placeholder="é€‰æ‹©æ¨¡å‹">
          <option v-for="model in currModels" :key="model" :value="model">{{ model }}</option>
        </select>
        <select v-model="config.theme" @change="themeChange" placeholder="é€‰æ‹©ä»£ç ä¸»é¢˜">
          <option v-for="theme in themes" :key="theme" :value="theme">{{ theme }}</option>
        </select>
        <button @click="createNewChat">+æ–°å¯¹è¯</button>
      </div>
      <div class="history">
        <div v-for="(chat, index) in chatHistory" :key="chat.id" class="history-item"
          :class="{ active: chat.id === currentChatId }" @click="selectChat(chat.id)">
          <span class="history-item-title">{{ chat.title }}</span>
          <button @click.stop="deleteChat(chat.id)" class="delete-chat">Ã—</button>
        </div>
      </div>
    </div>
    <div class="chat-container" @click="showSidebar = false">
      <div class="chat-messages" ref="chatMessages" @click="handleChatClick">
        <div v-for="(message, index) in currentChatMessages" :key="index" :id="'curr-chat-' + index" class="message-wrapper" :class="message.role">
          <div class="avatar">{{ message.role === 'user' ? 'U' : 'AI' }}</div>
          <div class="content">
            <div v-if="message.isError">
              <span>è¯·æ±‚å¤±è´¥, è¯·æ‰“å¼€è°ƒè¯•çª—å£æŸ¥çœ‹é”™è¯¯ä¿¡æ¯.</span>
              <button class="retry-btn" @click="retryLastMessage">é‡è¯•</button>
            </div>
            <div v-else class="prose" v-html="renderMarkdown(message.content)"></div>
            <div v-if="isStreaming && index === currentChatMessages.length - 1" class="pulse-dots"><i></i><i></i><i></i></div>
            <div v-if="!message.isError" class="message-actions">
              <button v-show="message.content" class="action-btn" @click="e => copyToClipboard(message.content, e.target)">å¤åˆ¶</button>
              <button v-if="message.role === 'assistant' && index === currentChatMessages.length - 1" class="action-btn" @click="retryLastMessage">é‡è¯•</button>
              <button v-if="message.role === 'user'" class="action-btn" @click="userInput = message.content">é‡é—®</button>
              <button v-if="message.role === 'user'" class="action-btn" @click="delMessage(message, index)">åˆ é™¤</button>
              <div v-if="message.tokenCount" class="token-count"><span v-if="message.remark">æ¨¡å‹: {{ message.remark }} </span> é•¿åº¦: {{ message.tokenCount }}</div>
            </div>
          </div>
        </div>
      </div>
      <div class="chat-input-area">
        <div class="input-before" title="æ”¯æŒä¸Šä¸‹æ–‡, æ¶ˆè€—æ›´å¤štoken" @click="useContext =! useContext">{{ useContext ? 'ğŸŸ¢' : 'ğŸ”´' }}</div>
        <div class="chat-input-wrapper">
          <textarea v-model="userInput" class="chat-input" @keydown.enter="handleEnter"
            placeholder="è¾“å…¥æ¶ˆæ¯æé—®...(Shift+Enter æ¢è¡Œ)" rows="1"></textarea>
          <button v-if="userInput" class="send-btn del" @click="userInput = ''">âœ–</button>
          <button v-if="!isStreaming" class="send-btn" @click="sendMessage">â¤</button>
          <button v-if="isStreaming" class="stop-btn" @click="stopStream">â– </button>
        </div>
        <div id="to-top" @click="scrollToBottom" @dblclick="goTop" title="åŒå‡»å›é¡¶éƒ¨">â‡©</div>
      </div>
      <div class="toggle-side" @click.stop="showSidebar = !showSidebar">ğŸ“°</div>
    </div>
    <div class="chat-nav">
      <div class="nav-item" v-for="(message, ind) in currentChatMessages" :key="ind" @click="selectChat(currentChatId)">
          <span v-if="message.role === 'user'" @click="scrollToChat(ind)"><i>â¤</i>{{ message.content }}</span>
      </div>
    </div>
    <div class="dialog" v-show="dialogShow" @click.self="dialogShow = false">
      <div class="dialog-cont"><iframe :src="dialogHtml" frameborder="0"></iframe></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.5.17/vue.global.prod.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.0.0/lib/marked.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-batch.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <!-- <script src="index.js"></script> -->
  <script src="index.min.js"></script>

  <script>
    localforage.setDriver([localforage.WEBSQL, localforage.INDEXEDDB])
    localforage.config({
      driver: localforage.INDEXEDDB,
      name: 'dai-data-db',
      storeName: 'daistore',
    });
    const themeList = ['prism', 'prism-coy', 'prism-okaidia', 'prism-tomorrow', 'prism-solarizedlight', 't-prism-vs', 't-prism-vsc-dark-plus',
     't-prism-a11y-dark', 't-prism-atom-dark', 't-prism-coldark-cold', 't-prism-coldark-dark',  't-prism-darcula', 't-prism-dracula', 't-prism-nord',
     't-prism-ghcolors', 't-prism-hopscotch', 't-prism-lucario', 't-prism-material-dark', 't-prism-material-oceanic', 't-prism-one-dark', 't-prism-one-light']

    const { createApp, ref, onMounted, nextTick, computed, watch } = Vue;

    const app = createApp({
      data() {
        return {
          showSidebar: false,
          dialogShow: false,
          dialogHtml: '',
          providers: [],
          currProvider: '',
          currModel: '',
          userInput: '',
          chatHistory: [],
          currentChatId: null,
          isStreaming: false,
          isDarkMode: false,
          abortController: null,
          useContext: localStorage.getItem('dai-useContext') === 'true',
          themes: themeList,
          config: {
            theme: 'prism',
            codeLine: 0,

          }
        };
      },
      computed: {
        currModels() {
          return this.providers.find(x => x.name === this.currProvider)?.models.split(/ã€|,|ï¼Œ|\s+/).map(m => m.trim()).filter(m => m)
           ?? [];
        },
        currentChat() {
          return this.chatHistory.find(chat => chat.id === this.currentChatId);
        },
        currentChatMessages() {
          return this.currentChat ? this.currentChat.messages : [];
        }
      },
      watch: {
        isDarkMode(val) {
          localforage.setItem('theme', val ? 'dark' : 'light');
          document.documentElement.className = val ? 'dark' : '';
          document.querySelector("#theme-link").href = !val ? this.getThemeLink(this.config.theme)
            : 'https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-vsc-dark-plus.min.css';
        },
        useContext(val) {
          localStorage.setItem('dai-useContext', val);
        },
        userInput() {
          // è‡ªåŠ¨è°ƒæ•´textareaé«˜åº¦
          this.$nextTick(() => {
            const textarea = document.querySelector('.chat-input');
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight + 2) + 'px';
          });
        }
      },
      mounted() {
        this.loadDataFromStorage();
        // åˆå§‹åŒ–textareaé«˜åº¦
        this.userInput = ' ';
        this.$nextTick(() => { this.userInput = ''; });
      },
      methods: {
        open(url) { window.open(url) },
        saveHistory() {
            let data = zipStr8(JSON.stringify(this.chatHistory));
            console.log(`save chatHistory, length: ${data.length}, size: ${(data.length / 1024).toFixed(2)}kb`);
            localforage.setItem('chatHistory', data);
        },
        renderMarkdown(content) {
          const rawHtml = marked.parse(content);
          const template = document.createElement('template');
          template.innerHTML = rawHtml.trim();
          template.content.querySelectorAll('a').forEach(x => x.setAttribute('target', '_blank'));
          template.content.querySelectorAll('pre code').forEach((codeEle) => {
            const pre = codeEle.parentElement;
            pre.classList.add('line-numbers');
            if (codeEle.className.includes('html') && !pre.querySelector('.run-btn')) {
              appendNode(pre, 'button', 'â–¶ï¸è¿è¡Œ', 'run-btn');
            }
            if (this.config.codeLine > 0 && codeEle.textContent.split('\n').length > this.config.codeLine) {
              appendNode(pre, 'button', 'å±•å¼€', 'expand-btn');
              pre.classList.add('over-code');
            }
            if (pre.querySelector('.copy-code-btn')) return; // é¿å…é‡å¤æ·»åŠ 
            appendNode(pre, 'button', 'å¤åˆ¶', 'copy-code-btn');
            appendNode(pre, 'button', 'ä¸‹è½½', 'down-code-btn');
            if (codeEle.className == 'language-vue') codeEle.className = 'language-html';
            Prism.highlightElement(codeEle);
          });
          return template.innerHTML;
        },
        providerChange() {
          localStorage.setItem('dai-currProvider', this.currProvider);
          this.currModel = this.currModels[0] || '';
          this.modelChange()
        },
        modelChange() {
          localStorage.setItem('dai-currModel', this.currModel);
        },
        themeChange() {
          document.querySelector("#theme-link").href = this.getThemeLink(this.config.theme);
          localStorage.setItem('dai-theme', this.config.theme);
        },
        getThemeLink(theme) {
          return theme.startsWith('t-') ? `https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/${theme.replace('t-', '')}.min.css`
            : `https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/${theme}.min.css`;
        },
        handleChatClick(event) {
          if (event.target.classList.contains('copy-code-btn')) {
            const pre = event.target.closest('pre');
            if (pre) {
              const codeEle = pre.querySelector('code');
              if (codeEle) this.copyToClipboard(codeEle.textContent, event.target);
            }
          }
          if (event.target.classList.contains('down-code-btn')) {
            const pre = event.target.closest('pre');
            if (pre) {
              const codeEle = pre.querySelector('code');
              // æ ¹æ®codeçš„languageç”Ÿæˆæ–‡ä»¶åç¼€å
              if (codeEle) downloadText(codeEle.textContent, 'index' + getFileExt(codeEle));
            }
          }
          if (event.target.classList.contains('expand-btn')) {
            const pre = event.target.closest('pre');
            if (pre) {
              pre.classList.toggle('over-code');
              event.target.textContent = event.target.textContent === 'å±•å¼€' ? 'æ”¶ç¼©' : 'å±•å¼€';
            }
          }
          if (event.target.classList.contains('run-btn')) {
            const pre = event.target.closest('pre');
            if (pre) {
              const codeEle = pre.querySelector('code');
              if (codeEle) {
                const prose = event.target.closest('.prose');
                let styleHtml = '', jsHtml = '';
                console.log(prose.querySelectorAll('code[class="language-css"]'));
                prose.querySelectorAll('code[class="language-css"]').forEach((c) => styleHtml += c.textContent);
                prose.querySelectorAll('code[class="language-javascript"]').forEach((c) => jsHtml += c.textContent);
                localStorage.setItem('dai-runHtml', codeEle.textContent.replace('<\/body>', `<style>\n${styleHtml}<\/style>\n<script>\n${jsHtml}<\/script>\n<\/body>`));
                // if (window.openWin && !window.openWin.closed) {
                //   window.openWin.location.reload()
                // } else {
                  window.openWin = window.open('run.html');
                // }
                window.openWin.focus()
              };
            }
          }
        },
        scrollToChat(ind) {
          document.querySelector('#curr-chat-' + ind)?.scrollIntoView({ behavior: 'smooth' });
        },
        scrollToBottom() {
          nextTick(() => {
            const chatMessages = this.$refs.chatMessages;
            if (chatMessages) {
              chatMessages.scrollTop = chatMessages.scrollHeight;
            }
          });
        },
        goTop() {
          const chatMessages = this.$refs.chatMessages;
          chatMessages && chatMessages.scrollTo({ top: 0, behavior: 'smooth'})
        },
        handleEnter(e) {
          if (e.ctrlKey || !e.shiftKey) {
            e.preventDefault();
            this.sendMessage()
          }
        },
        delMessage(msg, index) {
          if (confirm(`ç¡®å®šè¦åˆ é™¤è¯¥æ¡æ¶ˆæ¯å’Œå›ç­”å—?`)) {
            this.currentChat.messages.splice(index, 2);
            this.saveHistory()
          }
        },
        async sendMessage() {
          if (!this.userInput.trim() || this.isStreaming) return;
          console.log(this.providers, this.currProvider, this.currModel, this.userInput);
          const provider = this.providers.find(p => p.name === this.currProvider);
          if (!provider || !provider.url) return alert(`æ²¡æœ‰é…ç½®æ­£ç¡®çš„æœåŠ¡å•†(${provider.name})urlï¼Œæ— æ³•å‘é€è¯·æ±‚ã€‚`);
          if (!provider.key) return alert('æ²¡æœ‰é…ç½®æ­£ç¡®çš„keyï¼Œæ— æ³•å‘é€è¯·æ±‚ã€‚');
          if (!this.currModel) return alert('è¯·å…ˆé€‰æ‹©æ¨¡å‹ã€‚');

          const userMessage = { role: 'user', content: this.userInput.trim() };
          if (!this.currentChat) {
            this.createNewChat();
          }
          this.currentChat.messages.push(userMessage);
          this.userInput = '';
          this.scrollToBottom();

          const aiMessage = { role: 'assistant', content: '', remark: '', tokenCount: 0, isError: false };
          this.currentChat.messages.push(aiMessage);
          const reactiveAIMessage = this.currentChat.messages[this.currentChat.messages.length - 1];

          this.isStreaming = true;
          this.abortController = new AbortController();
          this.saveHistory()
          const startTime = Date.now();

          try {
            const response = await fetch(provider.url + '/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + provider.key
              },
              body: JSON.stringify({
                model: this.currModel,
                messages: this.currentChat.messages.slice(this.useContext ? 0 : -2, -1).map(m => ({ role: m.role, content: m.content })),
                stream: true,
                frequency_penalty: 0, // æ–‡æœ¬çš„æµç•…æ€§å’Œå®Œæ•´æ€§ï¼Œå³ä½¿å®ƒå¯èƒ½åŒ…å«ä¸€äº›é‡å¤
                presence_penalty: 0,
                stream_options: {include_usage: true }, // è¿”å›ä½¿ç”¨é‡
                temperature: 0.6, // 0-2 è¶Šå°éšæœºæ€§è¶Šå°
                top_p: 1,
              }),
              signal: this.abortController.signal,
            });

            if (!response.ok) {
              throw new Error(`Network response was not ok. Status: ${response.status}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split('\n');
              buffer = lines.pop();

              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  const data = line.substring(6);
                  console.log(data);
                  if (data.trim() === '[DONE]') {
                    return;
                  }
                  try {
                    const json = JSON.parse(data);
                    console.log(json);
                    if (json.choices && json.choices[0].delta && json.choices[0].delta.content) {
                      const delta = json.choices[0].delta.content;
                      reactiveAIMessage.content += delta;
                      this.scrollToBottom();
                    }
                  } catch (e) {
                    console.error('Error parsing stream data chunk:', data, e);
                  }
                }
              }
            }
          } catch (error) {
            if (error.name === 'AbortError') {
              reactiveAIMessage.content += '\n\n(è¯·æ±‚å·²ä¸­æ–­)';
            } else {
              reactiveAIMessage.isError = true;
              reactiveAIMessage.content = `è¯·æ±‚å¤±è´¥: ${error.message}`;
            }
          } finally {
            this.isStreaming = false;
            this.abortController = null;
            // æ¨¡æ‹Ÿè·å–tokenæ¶ˆè€—
            reactiveAIMessage.tokenCount = reactiveAIMessage.content.length;
            reactiveAIMessage.remark = provider.name + '(' + this.currModel + '), ' + ((Date.now() - startTime) / 1000).toFixed(0) + 's'
            this.scrollToBottom();
            if (this.currentChat.messages.length === 2 && this.currentChat.title === 'æ–°å¯¹è¯') {
              this.currentChat.title = this.currentChat.messages[0].content.substring(0, 30);
            }
            this.saveHistory()
          }
        },
        stopStream() {
          if (this.abortController) {
            this.abortController.abort();
          }
        },
        retryLastMessage() {
          const lastMessageIndex = this.currentChat.messages.length - 1;
          if (!this.currentChat.messages[lastMessageIndex].isError && !confirm('æ˜¯å¦ç¡®å®šé‡è¯•å›ç­”æ­¤æ¶ˆæ¯ï¼Ÿ')) {
            return
          }
          if (lastMessageIndex >= 0) { //  && this.currentChat.messages[lastMessageIndex].isError
            this.currentChat.messages.pop(); // ç§»é™¤é”™è¯¯æ¶ˆæ¯
            const lastUserMessage = this.currentChat.messages[this.currentChat.messages.length - 1];
            if (lastUserMessage && lastUserMessage.role === 'user') {
              this.userInput = lastUserMessage.content;
              this.currentChat.messages.pop(); // ç§»é™¤æœ€åçš„ç”¨æˆ·æ¶ˆæ¯ä»¥ä¾¿é‡æ–°å‘é€
              this.sendMessage();
            }
          }
        },
        copyToClipboard(text, buttonElement) {
          navigator.clipboard.writeText(text).then(() => {
            if (buttonElement) {
              const originalText = buttonElement.innerText;
              buttonElement.innerText = 'å·²å¤åˆ¶';
              setTimeout(() => { buttonElement.innerText = originalText }, 2000);
            }
          }).catch(err => {
            console.error('æ— æ³•å¤åˆ¶æ–‡æœ¬: ', err);
            alert('å¤åˆ¶å¤±è´¥!');
          });
        },
        createNewChat() {
          const newChat = {
            id: Date.now(),
            title: 'æ–°å¯¹è¯',
            messages: [],
          };
          this.chatHistory.unshift(newChat);
          this.currentChatId = newChat.id;
          this.saveHistory()
        },
        selectChat(chatId) {
          this.currentChatId = chatId;
        },
        deleteChat(chatId) {
          const chatIndex = this.chatHistory.findIndex(chat => chat.id === chatId);
          if (chatIndex === -1) return;
          console.log(this.chatHistory[chatIndex]);
          if (this.chatHistory[chatIndex].messages.length > 0 && !confirm(`ç¡®å®šåˆ é™¤è¯¥ä¼šè¯å—?`)) return;

          this.chatHistory.splice(chatIndex, 1);
          this.saveHistory()

          if (this.currentChatId === chatId) {
            if (this.chatHistory.length > 0) {
              // é€‰ä¸­è¢«åˆ é™¤é¡¹çš„ä¸‹ä¸€ä¸ªæˆ–ä¸Šä¸€ä¸ªï¼Œæˆ–è€…ç¬¬ä¸€ä¸ª
              const newIndex = Math.min(chatIndex, this.chatHistory.length - 1);
              this.currentChatId = this.chatHistory[newIndex].id;
            } else {
              this.createNewChat();
            }
          }
        },
        toggleTheme() {
          this.isDarkMode = !this.isDarkMode;
        },
        async loadDataFromStorage() {
          let history = await localforage.getItem('chatHistory');
          if (history) {
            if (history instanceof Uint8Array) {
              history = unzipStr8(history);
            }
            this.chatHistory = JSON.parse(history);
          }
          if (this.chatHistory.length > 0) {
            this.currentChatId = this.chatHistory[0].id;
          } else {
            this.createNewChat();
          }
          const theme = await localforage.getItem('theme');
          this.isDarkMode = theme === 'dark';
          this.config.theme = localStorage.getItem('dai-theme') || 'prism';
          if (!this.isDarkMode) {
            this.themeChange()
          }
          this.config.codeLine = localStorage.getItem("dai-codeLine") || 0;
          let settingStr = localStorage.getItem("dai-setting");
          if(settingStr) {
            const setting = JSON.parse(settingStr);
            if (setting.providers && setting.providers.length) {
              this.providers = setting.providers;
              this.currProvider = localStorage.getItem("dai-currProvider") || this.providers[0].name;
              this.currModel = localStorage.getItem("dai-currModel") || this.providers[0].defaultModel;
              return;
            }
          }
          if (confirm('æ‚¨è¿˜æ²¡æœ‰é…ç½®ä»»ä½•æœåŠ¡å•†, æ˜¯å¦å‰å¾€é…ç½®?')) {
            window.open('./setting.html')
          }
        }
      },
    });

    vueApp = app.mount('#app');

    /**************** å·¥å…·å‡½æ•° *******************/
    // å‹ç¼©å­—ç¬¦ä¸²ä¸ºUint8Array
    function zipStr8(str) {
      return pako.deflate(new TextEncoder().encode(str), { level: 9 });
    }
    // è§£å‹Uint8Arrayä¸ºå­—ç¬¦ä¸² // arr instanceof Uint8Array === true
    function unzipStr8(arr) {
      return pako.inflate(arr, { to: 'string' });
    }

    function appendNode(parent, name, text, cls) {
      var btn = document.createElement(name);
      btn.innerText = text;
      btn.className = cls;
      parent.appendChild(btn);
      return btn;
    }

    function downloadText(text, name) {
      const url = URL.createObjectURL(new Blob([text], { type: 'text/plain;charset=utf-8' }));
      const link = Object.assign(document.createElement('a'), { href: url, download: name });
      document.body.appendChild(link).click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function getFileExt(ele) {
      const extensionMap = {
        js: 'js', javascript: 'js', ts: 'ts', typescript: 'ts', py: 'py', python: 'py', java: 'java', c: 'c', sql: 'sql', 
        cpp: 'cpp', 'c++': 'cpp', cs: 'cs', csharp: 'cs',  go: 'go', php: 'php', ruby: 'rb', html: 'html', xml: 'xml', json: 'json',
        css: 'css', scss: 'scss', less: 'less', yml: 'yml', yaml: 'yaml', shell: 'sh', bash: 'sh', sh: 'sh', bat: 'bat', batch: 'bat',
      };
      if (!ele || !ele.classList) return '';
      const cls = Array.from(ele.classList).find(x => x.startsWith('language-'));
      if (!cls) return '';
      const lang = cls.substring('language-'.length).toLowerCase();
      return '.' + (extensionMap[lang] || lang);
    }

  </script>
</body>

</html>
